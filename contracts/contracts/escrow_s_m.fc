;; ============================================
;; Ziver Escrow Smart Contract (escrow_s_m.fc)
;; Modern FunC | Copy-Paste Ready | Fully Commented
;; ============================================

#include "imports/stdlib.fc"
;; Import standard FunC library for dict/cell helpers

;; --------------------------------------------
;; Error Codes -- Used for throw/throw_if
;; --------------------------------------------
int error_not_owner = 100;                    ;; Only treasury can withdraw fees
int error_task_already_exists = 101;          ;; Task ID already exists
int error_task_not_found = 102;               ;; Task not found
int error_not_task_poster = 103;              ;; Only poster allowed
int error_invalid_state = 104;                ;; Invalid state for action
int error_insufficient_funds = 105;           ;; Not enough funds sent
int error_task_not_in_active_state = 106;     ;; Task not active/verification
int error_invalid_performer_address = 107;    ;; Invalid performer
int error_performer_not_found = 108;          ;; Performer not found
int error_task_not_pending_verification = 109;; Task not pending verification
int error_proof_already_submitted = 110;      ;; Proof already submitted
int error_not_performer_or_moderator = 111;   ;; Not allowed to dispute
int error_task_not_in_disputed_state = 112;   ;; Task not disputed
int error_not_moderator = 113;                ;; Only moderator allowed
int error_no_accumulated_fees = 114;          ;; No fees to withdraw
int error_expired_task = 115;                 ;; Task expired
int error_task_not_set_and_funds_pending = 116;;
int error_task_not_in_active_or_pending = 117;;
int error_already_completed_performer = 118;  ;; Already completed
int error_not_enough_performers_completed = 119;;
int error_unknown_opcode = 255;               ;; Fallback for invalid opcodes

;; --------------------------------------------
;; Opcodes -- Each internal message must use one
;; --------------------------------------------
int op_deploy = 0x61737467;                  ;; [unused, for deploy]
int op_send_task_details = 0x1a2b3c4d;       ;; Client posts new task
int op_deposit_funds = 0x5e6f7a8b;           ;; Poster funds escrow
int op_verify_task_completion = 0x9c0d1e2f;  ;; Poster verifies performer
int op_submit_proof = 0x3a4b5c6d;            ;; Performer submits proof
int op_raise_dispute = 0x7e8f9a0b;           ;; Dispute task
int op_resolve_dispute = 0x11223344;         ;; Moderator resolves
int op_withdraw_funds = 0x55667788;          ;; [not implemented]
int op_cancel_task_and_refund = 0x99aabbcc;  ;; Poster cancels task
int op_withdraw_fee = 0xddccbbaa;            ;; Treasury withdraws fees

;; --------------------------------------------
;; Escrow State Enum -- Task workflow status
;; --------------------------------------------
int STATE_IDLE = 0;                    ;; Initial state
int STATE_TASK_SET_AND_FUNDS_PENDING = 1;
int STATE_ACTIVE = 2;
int STATE_PENDING_VERIFICATION = 3;
int STATE_SETTLED = 4;
int STATE_DISPUTED = 5;
int STATE_EXPIRED = 6;
int STATE_REFUNDED = 7;

;; ============================================
;; Persistent Storage Layout
;; ============================================
;; Stored in c4 register:
;; - ziver_treasury_address: protocol fee collector (slice)
;; - tasks_dict: all tasks, keyed by task_id (cell)
;; - accumulated_ziver_fees: protocol fees not yet withdrawn (int)

(slice, cell, int) load_data() inline {
    slice ds = get_data().begin_parse();
    slice ziver_treasury_address = ds~load_msg_addr();
    cell tasks_dict = ds~load_dict();
    int accumulated_ziver_fees = ds~load_coins();
    return (ziver_treasury_address, tasks_dict, accumulated_ziver_fees);
}

() save_data(slice ziver_treasury_address, cell tasks_dict, int accumulated_ziver_fees) impure inline {
    set_data(
        begin_cell()
            .store_slice(ziver_treasury_address)
            .store_dict(tasks_dict)
            .store_coins(accumulated_ziver_fees)
        .end_cell()
    );
}

;; ============================================
;; Getters (off-chain, view methods)
;; ============================================

;; Returns the protocol treasury address
slice get_ziver_treasury_address() method_id {
    (slice ziver_treasury_address, cell _, int _) = load_data();
    return ziver_treasury_address;
}

;; Returns the total protocol fees not yet withdrawn
int get_accumulated_fees() method_id {
    (_, _, int accumulated_ziver_fees) = load_data();
    return accumulated_ziver_fees;
}

;; Returns all details for a given task (or null if not found)
tuple get_task_details(int task_id) method_id {
    (_, cell tasks_dict, _) = load_data();
    cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
    if (null?(task_details_cell)) {
        return null();
    } else {
        slice task_s = task_details_cell.begin_parse();
        return (
            task_s~load_msg_addr(),   ;; taskPosterAddress
            task_s~load_coins(),      ;; paymentPerPerformerAmount
            task_s~load_uint(32),     ;; numberOfPerformersNeeded
            task_s~load_dict(),       ;; performersCompleted
            task_s~load_uint(32),     ;; completedPerformersCount
            task_s~load_uint(256),    ;; taskDescriptionHash
            task_s~load_uint(256),    ;; taskGoalHash
            task_s~load_uint(64),     ;; expiryTimestamp
            task_s~load_coins(),      ;; totalEscrowedFunds
            task_s~load_uint(8),      ;; ziverFeePercentage
            task_s~load_msg_addr(),   ;; moderatorAddress
            task_s~load_uint(8),      ;; currentState
            task_s~load_dict()        ;; proofSubmissionMap
        );
    }
}

;; ============================================
;; Main Logic Entry: Internal Message Handler
;; ============================================

() recv_internal() impure {
    accept_message();  ;; Accept for gas

    slice in_msg_full = in_msg();
    int flags = in_msg_full~load_uint(4);
    if (flags & 1) { return (); }  ;; Ignore bounced

    slice sender_address = in_msg_full~load_msg_addr();
    int value_sent = in_msg_full~load_grams();
    slice in_msg_body = in_msg_full~load_ref().begin_parse();

    (slice ziver_treasury_address, cell tasks_dict, int accumulated_ziver_fees) = load_data();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    ;; ============================================
    ;; 1. Task Creation: Poster creates a new task
    ;; ============================================
    if (op == op_send_task_details) {
        int task_id = in_msg_body~load_uint(64);
        int payment_per_performer_amount = in_msg_body~load_coins();
        int number_of_performers_needed = in_msg_body~load_uint(32);
        int task_description_hash = in_msg_body~load_uint(256);
        int task_goal_hash = in_msg_body~load_uint(256);
        int expiry_timestamp = in_msg_body~load_uint(64);
        int ziver_fee_percentage = in_msg_body~load_uint(8);
        slice moderator_address = in_msg_body~load_msg_addr();

        throw_if(error_task_already_exists, ~null?(udict_get_ref?(tasks_dict, 64, task_id)));

        builder task_details_builder = begin_cell()
            .store_slice(sender_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(null())
            .store_uint(0, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(0)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(STATE_IDLE, 8)
            .store_dict(null());

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

        ;; Optional: Confirmation message to sender (client can ignore)
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32)
            .store_uint(0xdeffeed, 32)
            .store_uint(query_id, 64)
            .store_uint(task_id, 64)
            .end_cell();
        send_raw_message(msg, 64);

    ;; ============================================
    ;; 2. Deposit Funds: Poster funds task escrow
    ;; ============================================
    } else if (op == op_deposit_funds) {
        int task_id = in_msg_body~load_uint(64);
        cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
        throw_if(error_task_not_found, null?(task_details_cell));

        slice task_s = task_details_cell.begin_parse();
        slice task_poster_address = task_s~load_msg_addr();
        int payment_per_performer_amount = task_s~load_coins();
        int number_of_performers_needed = task_s~load_uint(32);
        cell performers_completed = task_s~load_dict();
        int completed_performers_count = task_s~load_uint(32);
        int task_description_hash = task_s~load_uint(256);
        int task_goal_hash = task_s~load_uint(256);
        int expiry_timestamp = task_s~load_uint(64);
        int current_total_escrowed_funds = task_s~load_coins();
        int ziver_fee_percentage = task_s~load_uint(8);
        slice moderator_address = task_s~load_msg_addr();
        int current_state = task_s~load_uint(8);
        cell proof_submission_map = task_s~load_dict();

        throw_if(error_not_task_poster, sender_address != task_poster_address);
        throw_if(error_invalid_state, current_state != STATE_IDLE && current_state != STATE_TASK_SET_AND_FUNDS_PENDING);

        int expected_total_funds = payment_per_performer_amount * number_of_performers_needed;
        int required_amount = expected_total_funds - current_total_escrowed_funds;
        throw_if(error_insufficient_funds, value_sent < required_amount);

        current_total_escrowed_funds += value_sent;
        int new_state = (current_total_escrowed_funds >= expected_total_funds) ? STATE_ACTIVE : STATE_TASK_SET_AND_FUNDS_PENDING;

        builder updated_task_details_builder = begin_cell()
            .store_slice(task_poster_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(performers_completed)
            .store_uint(completed_performers_count, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(current_total_escrowed_funds)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(new_state, 8)
            .store_dict(proof_submission_map);

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, updated_task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

        ;; Refund any overpayment to sender
        if (value_sent > required_amount) {
            var overpay_msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(sender_address)
                .store_coins(value_sent - required_amount)
                .store_uint(0, 1 + 4 + 4 + 64 + 32)
                .end_cell();
            send_raw_message(overpay_msg, 0);
        }

    ;; ============================================
    ;; 3. Verify Completion: Poster verifies performer
    ;; ============================================
    } else if (op == op_verify_task_completion) {
        int task_id = in_msg_body~load_uint(64);
        slice performer_address = in_msg_body~load_msg_addr();
        cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
        throw_if(error_task_not_found, null?(task_details_cell));

        slice task_s = task_details_cell.begin_parse();
        slice task_poster_address = task_s~load_msg_addr();
        int payment_per_performer_amount = task_s~load_coins();
        int number_of_performers_needed = task_s~load_uint(32);
        cell performers_completed = task_s~load_dict();
        int completed_performers_count = task_s~load_uint(32);
        int task_description_hash = task_s~load_uint(256);
        int task_goal_hash = task_s~load_uint(256);
        int expiry_timestamp = task_s~load_uint(64);
        int current_total_escrowed_funds = task_s~load_coins();
        int ziver_fee_percentage = task_s~load_uint(8);
        slice moderator_address = task_s~load_msg_addr();
        int current_state = task_s~load_uint(8);
        cell proof_submission_map = task_s~load_dict();

        throw_if(error_not_task_poster, sender_address != task_poster_address);
        throw_if(error_task_not_in_active_state, current_state != STATE_ACTIVE && current_state != STATE_PENDING_VERIFICATION);

        int is_completed_entry = udict_get_ref?(performers_completed, 256, performer_address.as_slice().hash());
        throw_if(error_already_completed_performer, ~null?(is_completed_entry));

        performers_completed = udict_set_ref(performers_completed, 256, performer_address.as_slice().hash(), begin_cell().end_cell());
        completed_performers_count += 1;

        int fee_amount = (payment_per_performer_amount * ziver_fee_percentage) / 100;
        int amount_to_performer = payment_per_performer_amount - fee_amount;
        throw_if(error_insufficient_funds, current_total_escrowed_funds < payment_per_performer_amount);
        current_total_escrowed_funds -= payment_per_performer_amount;
        accumulated_ziver_fees += fee_amount;

        var performer_msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(performer_address)
            .store_coins(amount_to_performer)
            .store_uint(0, 1 + 4 + 4 + 64 + 32)
            .end_cell();
        send_raw_message(performer_msg, 64);

        int new_state = (completed_performers_count >= number_of_performers_needed) ? STATE_SETTLED : STATE_PENDING_VERIFICATION;

        builder updated_task_details_builder = begin_cell()
            .store_slice(task_poster_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(performers_completed)
            .store_uint(completed_performers_count, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(current_total_escrowed_funds)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(new_state, 8)
            .store_dict(proof_submission_map);

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, updated_task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

    ;; ============================================
    ;; 4. Submit Proof: Performer submits proof
    ;; ============================================
    } else if (op == op_submit_proof) {
        int task_id = in_msg_body~load_uint(64);
        int proof);
        cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
        throw_if(error_task_not_found, null?(task_details_cell));

        slice task_s = task_details_cell.begin_parse();
        slice task_poster_address = task_s~load_msg_addr();
        int payment_per_performer_amount = task_s~load_coins();
        int number_of_performers_needed = task_s~load_uint(32);
        cell performers_completed = task_s~load_dict();
        int completed_performers_count = task_s~load_uint(32);
        int task_description_hash = task_s~load_uint(256);
        int task_goal_hash = task_s~load_uint(256);
        int expiry_timestamp = task_s~load_uint(64);
        int current_total_escrowed_funds = task_s~load_coins();
        int ziver_fee_percentage = task_s~load_uint(8);
        slice moderator_address = task_s~load_msg_addr();
        int current_state = task_s~load_uint(8);
        cell proof_submission_map = task_s~load_dict();

        throw_if(error_task_not_in_active_or_pending, current_state != STATE_ACTIVE && current_state != STATE_PENDING_VERIFICATION);

        int proof_entry = udict_get_ref?(proof_submission_map, 256, sender_address.as_slice().hash());
        throw_if(error_proof_already_submitted, ~null?(proof_entry));

        proof_submission_map = udict_set_ref(proof_submission_map, 256, sender_address.as_slice().hash(), begin_cell().store_uint(proof_hash, 256).end_cell());

        builder updated_task_details_builder = begin_cell()
            .store_slice(task_poster_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(performers_completed)
            .store_uint(completed_performers_count, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(current_total_escrowed_funds)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(current_state, 8)
            .store_dict(proof_submission_map);

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, updated_task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

    ;; ============================================
    ;; 5. Raise Dispute: Poster or performer disputes
    ;; ============================================
    } else if (op == op_raise_dispute) {
        int task_id = in_msg_body~load_uint(64);
        int reason_hash = in_msg_body~load_uint(256);
        cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
        throw_if(error_task_not_found, null?(task_details_cell));

        slice task_s = task_details_cell.begin_parse();
        slice task_poster_address = task_s~load_msg_addr();
        int payment_per_performer_amount = task_s~load_coins();
        int number_of_performers_needed = task_s~load_uint(32);
        cell performers_completed = task_s~load_dict();
        int completed_performers_count = task_s~load_uint(32);
        int task_description_hash = task_s~load_uint(256);
        int task_goal_hash = task_s~load_uint(256);
        int expiry_timestamp = task_s~load_uint(64);
        int current_total_escrowed_funds = task_s~load_coins();
        int ziver_fee_percentage = task_s~load_uint(8);
        slice moderator_address = task_s~load_msg_addr();
        int current_state = task_s~load_uint(8);
        cell proof_submission_map = task_s~load_dict();

        throw_if(error_invalid_state, current_state != STATE_ACTIVE && current_state != STATE_PENDING_VERIFICATION);

        int is_performer_with_proof = udict_get_ref?(proof_submission_map, 256, sender_address.as_slice().hash());
        throw_if(error_not_performer_or_moderator, sender_address != task_poster_address && null?(is_performer_with_proof));

        int new_state = STATE_DISPUTED;

        builder updated_task_details_builder = begin_cell()
            .store_slice(task_poster_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(performers_completed)
            .store_uint(completed_performers_count, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(current_total_escrowed_funds)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(new_state, 8)
            .store_dict(proof_submission_map);

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, updated_task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

    ;; ============================================
    ;; 6. Resolve Dispute: Moderator resolves
    ;; ============================================
    } else if (op == op_resolve_dispute) {
        int task_id = in_msg_body~load_uint(64);
        slice winner_address = in_msg_body~load_msg_addr();
        cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
        throw_if(error_task_not_found, null?(task_details_cell));

        slice task_s = task_details_cell.begin_parse();
        slice task_poster_address = task_s~load_msg_addr();
        int payment_per_performer_amount = task_s~load_coins();
        int number_of_performers_needed = task_s~load_uint(32);
        cell performers_completed = task_s~load_dict();
        int completed_performers_count = task_s~load_uint(32);
        int task_description_hash = task_s~load_uint(256);
        int task_goal_hash = task_s~load_uint(256);
        int expiry_timestamp = task_s~load_uint(64);
        int current_total_escrowed_funds = task_s~load_coins();
        int ziver_fee_percentage = task_s~load_uint(8);
        slice moderator_address = task_s~load_msg_addr();
        int current_state = task_s~load_uint(8);
        cell proof_submission_map = task_s~load_dict();

        throw_if(error_not_moderator, sender_address != moderator_address);
        throw_if(error_task_not_in_disputed_state, current_state != STATE_DISPUTED);

        int new_state = STATE_SETTLED;

        if (winner_address == task_poster_address) {
            var refund_msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(task_poster_address)
                .store_coins(current_total_escrowed_funds)
                .store_uint(0, 1 + 4 + 4 + 64 + 32)
                .end_cell();
            send_raw_message(refund_msg, 64);
            current_total_escrowed_funds = 0;
        } else {
            int is_completed_entry = udict_get_ref?(performers_completed, 256, winner_address.as_slice().hash());
            throw_if(error_already_completed_performer, ~null?(is_completed_entry));
            performers_completed = udict_set_ref(performers_completed, 256, winner_address.as_slice().hash(), begin_cell().end_cell());
            completed_performers_count += 1;

            int fee_amount = (payment_per_performer_amount * ziver_fee_percentage) / 100;
            int amount_to_winner = payment_per_performer_amount - fee_amount;
            throw_if(error_insufficient_funds, current_total_escrowed_funds < payment_per_performer_amount);
            current_total_escrowed_funds -= payment_per_performer_amount;
            accumulated_ziver_fees += fee_amount;

            var winner_msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(winner_address)
                .store_coins(amount_to_winner)
                .store_uint(0, 1 + 4 + 4 + 64 + 32)
                .end_cell();
            send_raw_message(winner_msg, 64);

            new_state = (completed_performers_count >= number_of_performers_needed) ? STATE_SETTLED : STATE_PENDING_VERIFICATION;
        }

        builder updated_task_details_builder = begin_cell()
            .store_slice(task_poster_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(performers_completed)
            .store_uint(completed_performers_count, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(current_total_escrowed_funds)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(new_state, 8)
            .store_dict(proof_submission_map);

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, updated_task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

    ;; ============================================
    ;; 7. Cancel Task & Refund: Poster cancels pre-activation
    ;; ============================================
    } else if (op == op_cancel_task_and_refund) {
        int task_id = in_msg_body~load_uint(64);
        cell task_details_cell = udict_get_ref?(tasks_dict, 64, task_id);
        throw_if(error_task_not_found, null?(task_details_cell));

        slice task_s = task_details_cell.begin_parse();
        slice task_poster_address = task_s~load_msg_addr();
        int payment_per_performer_amount = task_s~load_coins();
        int number_of_performers_needed = task_s~load_uint(32);
        cell performers_completed = task_s~load_dict();
        int completed_performers_count = task_s~load_uint(32);
        int task_description_hash = task_s~load_uint(256);
        int task_goal_hash = task_s~load_uint(256);
        int expiry_timestamp = task_s~load_uint(64);
        int current_total_escrowed_funds = task_s~load_coins();
        int ziver_fee_percentage = task_s~load_uint(8);
        slice moderator_address = task_s~load_msg_addr();
        int current_state = task_s~load_uint(8);
        cell proof_submission_map = task_s~load_dict();

        throw_if(error_not_task_poster, sender_address != task_poster_address);
        throw_if(error_invalid_state, current_state != STATE_IDLE && current_state != STATE_TASK_SET_AND_FUNDS_PENDING);

        if (current_total_escrowed_funds > 0) {
            var refund_msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(task_poster_address)
                .store_coins(current_total_escrowed_funds)
                .store_uint(0, 1 + 4 + 4 + 64 + 32)
                .end_cell();
            send_raw_message(refund_msg, 64);
            current_total_escrowed_funds = 0;
        }

        int new_state = STATE_REFUNDED;

        builder updated_task_details_builder = begin_cell()
            .store_slice(task_poster_address)
            .store_coins(payment_per_performer_amount)
            .store_uint(number_of_performers_needed, 32)
            .store_dict(performers_completed)
            .store_uint(completed_performers_count, 32)
            .store_uint(task_description_hash, 256)
            .store_uint(task_goal_hash, 256)
            .store_uint(expiry_timestamp, 64)
            .store_coins(current_total_escrowed_funds)
            .store_uint(ziver_fee_percentage, 8)
            .store_slice(moderator_address)
            .store_uint(new_state, 8)
            .store_dict(proof_submission_map);

        tasks_dict = udict_set_ref(tasks_dict, 64, task_id, updated_task_details_builder.end_cell());
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

    ;; ============================================
    ;; 8. Withdraw Protocol Fees: Only treasury can withdraw
    ;; ============================================
    } else if (op == op_withdraw_fee) {
        throw_if(error_not_owner, sender_address != ziver_treasury_address);
        throw_if(error_no_accumulated_fees, accumulated_ziver_fees <= 0);

        var withdraw_msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(ziver_treasury_address)
            .store_coins(accumulated_ziver_fees)
            .store_uint(0, 1 + 4 + 4 + 64 + 32)
            .end_cell();
        send_raw_message(withdraw_msg, 64);

        accumulated_ziver_fees = 0;
        save_data(ziver_treasury_address, tasks_dict, accumulated_ziver_fees);

    ;; ============================================
    ;; 9. Fallback: Unknown Opcode
    ;; ============================================
    } else {
        throw(error_unknown_opcode);
    }
}